<!DOCTYPE html>
<html lang="en">

<head>
    <title>UE4 TaskGraph 学习笔记：介绍与实践 | Celestial</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://paakmau.github.io/style.css">
    <link rel="stylesheet" href="https://paakmau.github.io/color/orange-auto.css">

        <link rel="stylesheet" href="https://paakmau.github.io/color/background_auto.css">
    
    <link rel="stylesheet" href="https://paakmau.github.io/font-hack-subset.css">

    <meta name="description" content="">

    <meta property="og:description" content="">
    <meta property="og:title" content="UE4 TaskGraph 学习笔记：介绍与实践 | Celestial">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://paakmau.github.io/202003191321/">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" content="">
    <meta name="twitter:title" content="UE4 TaskGraph 学习笔记：介绍与实践 | Celestial">
    <meta property="twitter:domain" content="paakmau.github.io">
    <meta property="twitter:url" content="https://paakmau.github.io/202003191321/">

                <link rel="alternate" type="application/rss+xml" title="Celestial RSS Feed" href="https://paakmau.github.io/rss.xml" />
                <link rel="alternate" type="application/atom+xml" title="Celestial Atom Feed" href="https://paakmau.github.io/atom.xml" />
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'neutral'
        });
    </script>
</head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://paakmau.github.io" style="text-decoration: none;">
                    <div class="logo">
                      
                            Celestial
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li class="active"><a href="https://paakmau.github.io">home</a></li>
            
                <li><a href="https://paakmau.github.io/tags">tags</a></li>
            
                <li><a href="https://github.com/paakmau" target="_blank" rel="noopener noreferrer">github</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://paakmau.github.io/202003191321/">UE4 TaskGraph 学习笔记：介绍与实践</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2020-03-19
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://paakmau.github.io/tags/tu-lun/">#图论</a>&nbsp;
                <a class="post-tag" href="https://paakmau.github.io/tags/bing-fa/">#并发</a>&nbsp;
                <a class="post-tag" href="https://paakmau.github.io/tags/tuo-bu-pai-xu/">#拓扑排序</a></span>
    

        <div class="post-content">
            <p>这个东西跟 Unity 中的 Job 很相似，都是基于任务的并行程序设计，可以处理资源竞争与执行顺序问题</p>
<span id="continue-reading"></span><h2 id="jian-dan-jie-shao">简单介绍</h2>
<p>简单说就是一张有向无环图，每一个任务是结点，任务的依赖关系是边，根据拓扑排序规划任务的执行。如果一个结点的入度为零就可以并行，并且执行完成后删掉自己的出边；否则等待入边的结点执行完成</p>
<ul>
<li>结点是 <code>TGraphTask</code> 模版类，我们需要自己实现任务类满足它的要求。重点是实现 <code>DoTask</code> 方法</li>
<li>边是 <code>FGraphEventRef</code>，可以在 <code>CreateTask</code> 之后得到，可以理解为任务完成的事件；同时在 <code>CreateTask</code> 的时候可以把其他任务的 <code>FGraphEventRef</code> 以 <code>FGraphEventArray</code> 的形式传入以表示依赖（入边）</li>
</ul>
<p>另外，任务类的 <code>DoTask</code> 方法参数中有一个 <code>const FGraphEventRef &amp;MyCompletionGraphEvent</code>，根据变量名我们知道它是任务自身的完成事件。
于是我们还可以在这个东西上进行蛇皮操作，比如在本任务完成之前再等待另一个任务完成，但是写起来很乱</p>
<h2 id="hello-world">Hello World</h2>
<p>跟随下面的指引建立两个任务类，然后通过 <code>FGraphEventRef</code> 指定他们的执行顺序</p>
<p>准备两个任务类 <code>TestTaskA</code> 和 <code>TestTaskB</code><br>
<code>TestTaskA</code> 的代码如下，另外一个可以仿照着写</p>
<pre data-lang="cpp" style="background-color:#151515;color:#e8e8d3;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8fbfdc;">class </span><span style="color:#ffb964;">TestTaskA
</span><span>{
</span><span>
</span><span style="color:#8fbfdc;">public</span><span>:
</span><span>    </span><span style="color:#fad07a;">TestTaskA</span><span>() {
</span><span>        </span><span style="color:#888888;">// 底层使用了可变参数模板，因此构造函数可以添加任意的参数，但是注意不能传入引用
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#888888;">// 返回任务名
</span><span>    </span><span style="color:#8fbfdc;">static const </span><span>TCHAR* </span><span style="color:#fad07a;">GetTaskName</span><span>() { </span><span style="color:#8fbfdc;">return </span><span style="color:#ffb964;">TEXT</span><span>(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">TestTask</span><span style="color:#556633;">&quot;</span><span>); }
</span><span>    FORCEINLINE </span><span style="color:#8fbfdc;">static</span><span> TStatId </span><span style="color:#fad07a;">GetStatId</span><span>() { </span><span style="color:#ffb964;">RETURN_QUICK_DECLARE_CYCLE_STAT</span><span>(TestTask, STATGROUP_TaskGraphTasks); }
</span><span>    </span><span style="color:#888888;">// 返回 Task 所在的线程
</span><span>    </span><span style="color:#8fbfdc;">static</span><span> ENamedThreads::Type </span><span style="color:#fad07a;">GetDesiredThread</span><span>() { </span><span style="color:#8fbfdc;">return</span><span> ENamedThreads::AnyThread; }
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">static</span><span> ESubsequentsMode::Type </span><span style="color:#fad07a;">GetSubsequentsMode</span><span>()
</span><span>    {
</span><span>        </span><span style="color:#8fbfdc;">return</span><span> ESubsequentsMode::TrackSubsequents;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#888888;">// 任务的执行函数
</span><span>    </span><span style="color:#8fbfdc;">void </span><span style="color:#fad07a;">DoTask</span><span>(ENamedThreads::Type </span><span style="color:#ffb964;">CurrentThread</span><span>, </span><span style="color:#8fbfdc;">const</span><span> FGraphEventRef&amp; </span><span style="color:#ffb964;">MyCompletionGraphEvent</span><span>)
</span><span>    {
</span><span>        </span><span style="color:#888888;">// 这里是任务的逻辑代码
</span><span>        </span><span style="color:#8fbfdc;">for </span><span>(</span><span style="color:#8fbfdc;">int</span><span> Idx = </span><span style="color:#cf6a4c;">0</span><span>; Idx &lt; </span><span style="color:#cf6a4c;">5</span><span>; Idx++)
</span><span>        </span><span style="color:#ffb964;">UE_LOG</span><span>(LogTemp, Log, </span><span style="color:#ffb964;">TEXT</span><span>(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Task A executing</span><span style="color:#556633;">&quot;</span><span>));
</span><span>        </span><span style="color:#ffb964;">UE_LOG</span><span>(LogTemp, Log, </span><span style="color:#ffb964;">TEXT</span><span>(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Task A completed</span><span style="color:#556633;">&quot;</span><span>));
</span><span>    }
</span><span>};
</span></code></pre>
<p>创建一个 Actor，并修改 <code>BeginPlay</code> 方法如下</p>
<pre data-lang="cpp" style="background-color:#151515;color:#e8e8d3;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8fbfdc;">void </span><span>AMyActor::</span><span style="color:#fad07a;">BeginPlay</span><span>()
</span><span>{
</span><span>    Super::</span><span style="color:#ffb964;">BeginPlay</span><span>();
</span><span>    FGraphEventRef TaskA = TGraphTask&lt;TestTaskA&gt;::</span><span style="color:#ffb964;">CreateTask</span><span>().</span><span style="color:#ffb964;">ConstructAndDispatchWhenReady</span><span>();
</span><span>    FGraphEventArray DependencyForTaskB = { TaskA };
</span><span>    FGraphEventRef TaskB = TGraphTask&lt;TestTaskB&gt;::</span><span style="color:#ffb964;">CreateTask</span><span>(&amp;DependencyForTaskB).</span><span style="color:#ffb964;">ConstructAndDispatchWhenReady</span><span>();
</span><span>}
</span></code></pre>
<h2 id="parallelfor"><code>ParallelFor</code></h2>
<p>UE4 有一个 <code>ParallelFor</code>，是对于简单遍历的并行处理，基于 TaskGraph，具体去看 <code>Runtime/Core/Public/Async/ParallelFor.h</code><br>
下面给个简单的例子</p>
<pre data-lang="cpp" style="background-color:#151515;color:#e8e8d3;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#ffb964;">ParallelFor</span><span>(</span><span style="color:#cf6a4c;">100</span><span>, [](int32 CurrIdx) {
</span><span>    int32 Sum = </span><span style="color:#cf6a4c;">0</span><span>;
</span><span>    </span><span style="color:#8fbfdc;">for </span><span>(int32 Idx = </span><span style="color:#cf6a4c;">0</span><span>; Idx &lt; CurrIdx * </span><span style="color:#cf6a4c;">100</span><span>; ++Idx)
</span><span>        Sum += FMath::</span><span style="color:#ffb964;">Sqrt</span><span>(</span><span style="color:#cf6a4c;">1234.56</span><span style="color:#8fbfdc;">f</span><span>);
</span><span>});
</span></code></pre>
<h2 id="dui-bi-unity-c-job-system">对比 Unity C# Job System</h2>
<p>如果抽象成一张 DAG 来看，这两个本质上其实就是同一个东西。简单说就是通过建立依赖关系避免资源竞争实现易于管理的并行</p>
<p>但是 Job System 相对于 TaskGraph 在用户代码中出现频率要高得多。因为 Unity DOTS 天生就能很好的设计并行，甚至 Job 其实是嵌入在 <code>SystemBase</code> 里的，对于游戏主逻辑都能被频繁使用；而 UE4 是 OOP，个人理解的话应该主要用于耗时长的计算或者 I/O 任务等，但是把游戏主逻辑放到 TaskGraph 里是比较困难的</p>
<p>另外有一个小区别，UE4 的 <code>ParallerFor</code> 与 Unity 里的 <code>ScheduleParallel</code> 是不太一样的。UE4 的 ParallelFor 其实是基于 TaskGraph 的顶层；而 Unity 的 <code>ScheduleParallel</code> 是 Job 本身自带的方法</p>

        </div>

        
            <div class="pagination">
                <div class="pagination__title">
                    <span class="pagination__title-h">Thanks for reading! Read other posts?</span>
                    <hr />
                </div>
                <div class="pagination__buttons">
                        <span class="button previous">
                            <a href="https://paakmau.github.io/202003152207/">
                                <span class="button__icon">←</span>&nbsp;
                                <span class="button__text">Unity Physics 学习笔记第七章：精确的碰撞管理</span>
                            </a>
                        </span>
                    
                    
                        <span class="button next">
                            <a href="https://paakmau.github.io/202003222052/">
                                <span class="button__text">UE4 TaskGraph 学习笔记：源码阅读</span>&nbsp;
                                <span class="button__icon">→</span>
                            </a>
                        </span>
                    </div>
            </div>
        
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2025
 Powered by <a href="https://www.getzola.org/">Zola</a></span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep">:: </span>
                        Theme: <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
                    </span>
                </div>
            </div>
    </footer>
    

</div>
</body>

</html>
