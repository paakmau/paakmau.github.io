<!DOCTYPE html>
<html lang="en">

<head>
    <title>并发环境下实现懒加载 | Celestial</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://paakmau.github.io/style.css">
    <link rel="stylesheet" href="https://paakmau.github.io/color/orange-auto.css">

        <link rel="stylesheet" href="https://paakmau.github.io/color/background_auto.css">
    
    <link rel="stylesheet" href="https://paakmau.github.io/font-hack-subset.css">

    <meta name="description" content="">

    <meta property="og:description" content="">
    <meta property="og:title" content="并发环境下实现懒加载 | Celestial">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://paakmau.github.io/202007141756/">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" content="">
    <meta name="twitter:title" content="并发环境下实现懒加载 | Celestial">
    <meta property="twitter:domain" content="paakmau.github.io">
    <meta property="twitter:url" content="https://paakmau.github.io/202007141756/">

                <link rel="alternate" type="application/rss+xml" title="Celestial RSS Feed" href="https://paakmau.github.io/rss.xml" />
                <link rel="alternate" type="application/atom+xml" title="Celestial Atom Feed" href="https://paakmau.github.io/atom.xml" />
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'neutral'
        });
    </script>
</head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://paakmau.github.io" style="text-decoration: none;">
                    <div class="logo">
                      
                            Celestial
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li class="active"><a href="https://paakmau.github.io">home</a></li>
            
                <li><a href="https://paakmau.github.io/tags">tags</a></li>
            
                <li><a href="https://github.com/paakmau" target="_blank" rel="noopener noreferrer">github</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://paakmau.github.io/202007141756/">并发环境下实现懒加载</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2020-07-14
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://paakmau.github.io/tags/c/">#C++</a>&nbsp;
                <a class="post-tag" href="https://paakmau.github.io/tags/c-stl/">#C++ STL</a>&nbsp;
                <a class="post-tag" href="https://paakmau.github.io/tags/bing-fa/">#并发</a></span>
    

        <div class="post-content">
            <p>懒加载是指在用到某个变量时才进行初始化<br>
然后并发环境下懒加载可能会有访问冲突、重复初始化等问题，很容易爆炸<br>
因此需要一些操作</p>
<span id="continue-reading"></span><h2 id="dan-xian-cheng-lan-jia-zai">单线程懒加载</h2>
<p>一般这样写</p>
<pre data-lang="cpp" style="background-color:#151515;color:#e8e8d3;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8fbfdc;">class </span><span style="color:#ffb964;">Test
</span><span>{
</span><span>    shared_ptr&lt;string&gt; str;
</span><span>
</span><span style="color:#8fbfdc;">public</span><span>:
</span><span>    shared_ptr&lt;string&gt; </span><span style="color:#fad07a;">GetStr</span><span>()
</span><span>    {
</span><span>        </span><span style="color:#8fbfdc;">if </span><span>(!str)
</span><span>            str = </span><span style="color:#ffb964;">make_shared</span><span>&lt;string&gt;(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Test str</span><span style="color:#556633;">&quot;</span><span>);
</span><span>        </span><span style="color:#8fbfdc;">return</span><span> str;
</span><span>    }
</span><span>};
</span></code></pre>
<p>然后发现一个问题是如果 <code>str</code> 没有初始化，此时有多个线程同时访问 <code>GetStr</code> 方法，它们可能会同时把这个 <code>str</code> 初始化多次。虽然这里用的是 <code>string</code> 类型，问题不大，但如果是其他类型就很可能会爆炸</p>
<h2 id="jian-dan-jia-suo">简单加锁</h2>
<p>解决并发访问问题，可以加个锁</p>
<pre data-lang="cpp" style="background-color:#151515;color:#e8e8d3;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8fbfdc;">class </span><span style="color:#ffb964;">Test
</span><span>{
</span><span>    shared_ptr&lt;string&gt; str;
</span><span>    mutex mtx;
</span><span>
</span><span style="color:#8fbfdc;">public</span><span>:
</span><span>    shared_ptr&lt;string&gt; </span><span style="color:#fad07a;">GetStr</span><span>()
</span><span>    {
</span><span>        lock_guard&lt;mutex&gt; </span><span style="color:#ffb964;">lk</span><span>(mtx);
</span><span>        </span><span style="color:#8fbfdc;">if </span><span>(!str)
</span><span>            str = </span><span style="color:#ffb964;">make_shared</span><span>&lt;string&gt;(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Test str</span><span style="color:#556633;">&quot;</span><span>);
</span><span>        </span><span style="color:#8fbfdc;">return</span><span> str;
</span><span>    }
</span><span>};
</span></code></pre>
<p>然而这样写也有问题，假设对于 <code>str</code> 的访问（除了初始化）都是只读的，那么在 <code>str</code> 初始化之后其实各个线程访问 <code>str</code> 都是不会产生竞争条件的，根本不需要上锁，因此这样写会造成巨大的性能浪费</p>
<h2 id="double-check">Double check</h2>
<p>简单地说就是在上锁之前检查一下是否已经初始化，如果已经初始化了，就不用上锁。其实很简单，就是写起来不怎么高雅</p>
<p>为什么叫做 double check 呢，因为上锁之后还要检查一下初始化情况，所以总共检查两次</p>
<pre data-lang="cpp" style="background-color:#151515;color:#e8e8d3;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8fbfdc;">class </span><span style="color:#ffb964;">Test
</span><span>{
</span><span>    shared_ptr&lt;string&gt; str;
</span><span>    mutex mtx;
</span><span>
</span><span style="color:#8fbfdc;">public</span><span>:
</span><span>    shared_ptr&lt;string&gt; </span><span style="color:#fad07a;">GetStr</span><span>()
</span><span>    {
</span><span>        </span><span style="color:#8fbfdc;">if </span><span>(!str)
</span><span>        {
</span><span>            lock_guard&lt;mutex&gt; </span><span style="color:#ffb964;">lk</span><span>(mtx);
</span><span>            </span><span style="color:#8fbfdc;">if </span><span>(!str)
</span><span>                str = </span><span style="color:#ffb964;">make_shared</span><span>&lt;string&gt;(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Test str</span><span style="color:#556633;">&quot;</span><span>);
</span><span>        }
</span><span>        </span><span style="color:#8fbfdc;">return</span><span> str;
</span><span>    }
</span><span>};
</span></code></pre>
<p>然而这样写还是有风险。在某一个线程拿到了锁，初始化到一半的时候，也就是 <code>str</code> 的指针非空且分配了内存但是它内部数据没有初始化；而此时另一个线程却可以直接拿到 <code>str</code>，且 <code>str</code> 内部的数据是爆炸的，就会产生未定义行为。这种情况的原因可能是编译器指令重排或者处理器乱序执行</p>
<h2 id="std-call-once"><code>std::call_once</code></h2>
<p>C++ 钦定的只执行一次，看代码就行了</p>
<pre data-lang="cpp" style="background-color:#151515;color:#e8e8d3;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8fbfdc;">class </span><span style="color:#ffb964;">Test
</span><span>{
</span><span>    shared_ptr&lt;string&gt; str;
</span><span>    once_flag flag;
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">void </span><span style="color:#fad07a;">InitStr</span><span>() {
</span><span>        str = </span><span style="color:#ffb964;">make_shared</span><span>&lt;string&gt;(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Test str</span><span style="color:#556633;">&quot;</span><span>);
</span><span>    }
</span><span>
</span><span style="color:#8fbfdc;">public</span><span>:
</span><span>    shared_ptr&lt;string&gt; </span><span style="color:#fad07a;">GetStr</span><span>()
</span><span>    {
</span><span>        </span><span style="color:#ffb964;">call_once</span><span>(flag, &amp;Test::InitStr, </span><span style="color:#ffb964;">this</span><span>);
</span><span>        </span><span style="color:#8fbfdc;">return</span><span> str;
</span><span>    }
</span><span>};
</span></code></pre>
<h2 id="ju-bu-jing-tai-bian-liang">局部静态变量</h2>
<p>如果需要懒加载的对象是一个单例，可以考虑使用局部静态变量</p>
<p>局部静态变量只有在被用到的时候才会分配内存并初始化。当然看起来还是存在竞争条件，但是在 C++11 标准中，规定了静态局部变量要线程安全，所以还是可以放心食用</p>
<pre data-lang="cpp" style="background-color:#151515;color:#e8e8d3;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8fbfdc;">class </span><span style="color:#ffb964;">Test
</span><span>{
</span><span style="color:#8fbfdc;">public</span><span>:
</span><span>    shared_ptr&lt;string&gt; </span><span style="color:#fad07a;">GetStr</span><span>()
</span><span>    {
</span><span>        </span><span style="color:#8fbfdc;">static</span><span> shared_ptr&lt;string&gt; str = </span><span style="color:#ffb964;">make_shared</span><span>&lt;string&gt;(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Test_str</span><span style="color:#556633;">&quot;</span><span>);
</span><span>        </span><span style="color:#8fbfdc;">return</span><span> str;
</span><span>    }
</span><span>};
</span></code></pre>
<p>需要注意的是，静态成员变量、全局变量和文件域的静态变量都是在程序运行开始就分配内存并初始化好了，因此它们的初始化过程也是线程安全的，不过这样就不是懒加载了</p>

        </div>

        
            <div class="pagination">
                <div class="pagination__title">
                    <span class="pagination__title-h">Thanks for reading! Read other posts?</span>
                    <hr />
                </div>
                <div class="pagination__buttons">
                        <span class="button previous">
                            <a href="https://paakmau.github.io/202007112038/">
                                <span class="button__icon">←</span>&nbsp;
                                <span class="button__text">Win10 下 Perforce 命令行快速上手</span>
                            </a>
                        </span>
                    
                    
                        <span class="button next">
                            <a href="https://paakmau.github.io/202009032023/">
                                <span class="button__text">Vulkan 画三角形第一章：概要与环境配置</span>&nbsp;
                                <span class="button__icon">→</span>
                            </a>
                        </span>
                    </div>
            </div>
        
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2025
 Powered by <a href="https://www.getzola.org/">Zola</a></span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep">:: </span>
                        Theme: <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
                    </span>
                </div>
            </div>
    </footer>
    

</div>
</body>

</html>
